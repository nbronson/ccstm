
STM research is mature enough that the most difficult design decisions
for CCSTM were all found in the interface.

\subsection{Read barrier syntax}
\label{sec:syntax}

The most difficult syntactic choice was the method name for a
transactional read.  Three concise alternatives were considered:

\begin{packed_enum}

\item An implicit conversion from \xtype{Ref}{A} to \typeparam{A} -- This is
the most concise, but it interferes with further implicit conversions and type
inference for generic methods or data structures.  If \code{x} is a
\ytype{Ref}{String} holding \code{"foo"}, for example, \code{("foo" == x)}
would return false.

\item \code{unary\_!} -- A unary operator is the most concise explicit
way of denoting a read, and prefix forms of these are the only ones
that don't trigger Scala's line merging heuristic.  Initially we
settled on a \code{!} prefix for reads.  This works well for arithmetic
expressions, but it can be confusing when used in a conditional test,
as in \code{(!x == "foo")}.  It also does not chain well, requiring
extra parentheses: \code{(!x).length}.  Because of these problems, we
found ourself often reverting to the more verbose forms \code{(x.get ==
"foo")} and \code{x.get.length}.

\item \code{apply()} -- This is the only operator-like suffix method
that can safely occur at the end of the line, which means that it chains
properly in complex operations.  We initially avoided using it for read
barriers, because \code{()} is often used in Scala to help draw attention
to side-effecting methods.  Although read barriers do not themselves
perform a mutation, their access to shared mutable state also requires
extra care.  The current CCSTM code base uses \code{apply()} for concise
representation of read barriers.

\end{packed_enum}

For fields that are almost always accessed inside an atomic block, we
have also found it convenient to create transactional accessor methods.
The full \type{Ref} is published via a longer name for non-transactional
or advance operations, while the basic property name is available within
a transaction using Scala's basic field syntax:
\lstset{numbers=none}
\lstset{xleftmargin=0.125in}
\begin{lstlisting}
class Node {
  val nextRef: Ref[Node] = ..
  def next(implicit txn: Txn): Node = nextRef()
  def next_=(v: Node)(implicit txn: Txn) {
    nextRef := v 
  }
}
\end{lstlisting}
\lstset{xleftmargin=0.25in}
\lstset{numbers=left}

\color{green}
\subsection{Nested transactions}

CCSTM currently does not support nested atomic blocks, an important
omission.  A larger problem, though, is that the static scoping
of transactions would make composing such blocks difficult.  If a
method \code{m} needs a transaction internally, should it add an
\keyword{implicit} \type{Txn} parameter?  If it doesn't, then it
cannot be composed.  If it does, then the caller must always provide
an atomic block.  If the programmer wishes to provide both a simple
and a composable version of the method then he must come up with
two names.

The need for two versions of \code{m} parallels the transactional and
non-transactional access to a \type{Ref}, which was resolved there by the
\type{Ref} $\leftrightarrow$ \type{Ref.Bound} correspondence.  Rather than
coming up with two method names, the same method name can be used in
two classes.  \type{Ref}\code{.nonTxn} and \type{Ref.Bound}\code{.unbind}
convert from an instance suitable for one context to the other.  While it
may be tolerable to manage these parallel classes in the library itself,
it seems burdensome to ask the programmer to perform a similar task.

A possible solution is to provide dynamic scoping for the declaration
of atomic blocks, but static scoping for barriers.  Because nested
transactions are likely to be less common than barriers, there is less
performance motivation for avoiding the thread-local lookup.

It seems dangerous to mix static and dynamic scoping, but we notice that
for all but the most subtle uses, the static and dynamic scopes should be
identical.  This means that we can provide an execution mode that checks
the
static scopes against the dynamic ones, and triggers an exception 
if they don't match.  This checking mode would be slower on a per-barrier
basis, so like asserts it might be disabled during production use.

For applications that don't spend a large portion of their time in barriers, we
should also consider providing full dynamic scoping for transactions.
Interestingly, this could be enabled in a per-module fashion by providing an
implicit function that performs the required thread-local lookup.  The result
might look like:
\lstset{numbers=none}
\begin{lstlisting}
class Account ... {
  import STM.dynamic

  def deposit(amount: Money) {
    assert(amount >= 0)
    _balance := _balance() + amount
  }
}
\end{lstlisting}
\lstset{numbers=left}
If \code{deposit} were executed outside a transaction a runtime error would be
generated, rather than the compile-time error produced by the existing CCSTM.

Future: Partial rollback

Future: Collections

Future: Plugin

Future: @specialized

\color{black}
