
STM research is mature enough that the most difficult design decisions
for CCSTM were all found in the interface.

\subsection{Read barrier syntax}

The choice of \code{!x} as the preferred encoding for a transactional
read of \code{x} was inspired by ML's reference syntax.  Three alternatives
were considered for a concise transactional read:
\begin{packed_enum}
\item \code{apply()} -- This chains more easily than a prefix operator, without
triggering Scala's line merging heuristic.  Idiomatic Scala uses \code{()} to
denote a side-effecting method, however, which is confusing.
\item An implicit conversion from \xtype{Ref}{A} to \typeparam{A} -- This is
the most concise, but it interferes with further implicit conversions and
can lead to surprises.
\item \code{unary\_!} -- This adds only a single character, but it can be
confusing when a transactional read is used as part of a boolean condition.
It can be difficult to chain without parentheses.
\end{packed_enum}

In the code that we have written so far we have mixed \code{unary\_!} and
\code{.get}, falling back on the more verbose form inside conditionals and
complicated expressions.  For fields that are almost always accessed inside
an atomic block, another scheme that works well is to create transactional
accessor methods:
\lstset{numbers=none}
\begin{lstlisting}
class Node {
  private val _next: Ref[Node] = ..
  def next(implicit txn: Txn): Node = !_next
  def next_=(v: Node)(implicit txn: Txn): Unit =
      _next := v
}
\end{lstlisting}
\lstset{numbers=left}

\subsection{Nested transactions}

CCSTM currently does not support nested atomic blocks, an important
omission.  A bigger problem, though, is that the static scoping
of transactions would make composing such blocks difficult.  If a
method \code{m} needs a transaction internally, should it add an
\keyword{implicit} \type{Txn} parameter?  If it doesn't, then it
cannot be composed.  If it does, then the caller must always provide
an atomic block.  The the programmer wishes to provide both a simple
and a composable version of the method then he or she must come up with
two names.

The need for two versions of \code{m} parallels the transactional and
non-transactional access to a \type{Ref}, which was solved there by the
\type{Ref} $\leftrightarrow$ \type{Ref.Bound} correspondence.  Rather than
coming up with two method names, the same method name can be used in
two classes.  \type{Ref}\code{.nonTxn} and \type{Ref.Bound}\code{.unbind}
convert from an instance suitable for one context to the other.  While it
may be tolerable to manage these parallel classes in the library itself,
it seems onerous to ask the programmer to perform a similar task.

A possible solution is to provide dynamic scoping for the declaration
of atomic blocks, but static scoping for barriers.  Since nested
transactions are likely to be less common than barriers, there is less
performance motivation for avoiding the thread-local lookup.

It seems dangerous to mix static and dynamic scoping, but we notice that
for all but the most subtle uses, the static and dynamic scopes should be
identical.  This means that we can provide an execution mode in which the
static scopes are checked against the dynamic ones, and an assertion triggered
if they don't match up.  This checking mode would be slower on a per-barrier
basis, so it might be disabled during production use.

For applications that don't spend a large portion of their time in barriers, we
should also consider providing full dynamic scoping for transactions.
Interestingly, this could be enabled in a per-module fashion by providing an
implicit function that performs the required thread-local lookup.  The result
might look like:
\lstset{numbers=none}
\begin{lstlisting}
class Account ... {
  import STM.dynamic

  def deposit(amount: Money): Unit = {
    assert(amount >= 0)
    _balance := !_balance + amount
  }
}
\end{lstlisting}
\lstset{numbers=left}
If \code{deposit} were executed outside a transaction a runtime error would be
generated, rather than the compile-time error produced by the existing CCSTM.

