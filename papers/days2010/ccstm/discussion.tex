
STM research is mature enough that the most difficult design decisions
for CCSTM were all found in the interface.

\subsection{Read barrier syntax}
\label{sec:syntax}

The most difficult syntactic choice was the method name for a
transactional read.  Four alternatives were considered:

\begin{packed_enum}

\item Using property syntax to emulate a \keyword{var }\code{ elem}
in the \type{Ref} class -- To read the transactional value held by a
reference \code{x} the caller would use \code{x.elem}, and to update it
they would write \code{x.elem = v}.  This approach is self-consistent,
but it is much too verbose.

\item An implicit conversion from \xtype{Ref}{A} to \typeparam{A} --
This is the most concise, but it interferes with further implicit
conversions, and with type inference for generic methods or data
structures.  If \code{x} is a \ytype{Ref}{String} holding \code{"foo"},
for example, \code{("foo" == x)} would return false.

\item \code{unary\_!} -- A unary operator is the most concise explicit
way of denoting a read, and prefix forms of these are the only ones
that don't trigger Scala's line merging heuristic.  Initially we
settled on a \code{!} prefix for reads.  This works well for arithmetic
expressions, but it can be confusing when used in a conditional test,
as in \code{(!x == "foo")}.  It also does not chain well, requiring
extra parentheses: \code{(!x).length}.  Because of these problems, we
found ourself often reverting to the more verbose forms \code{(x.get ==
"foo")} and \code{x.get.length}.

\item \code{apply()} -- This is the only operator-like method that can
safely occur at the end of the line, which allows it to be placed after
the expression that produces the \type{Ref} to read.  This means that
it chains properly in complex operations.  We initially avoided using
\code{apply()} for read barriers, because inclusion of optional parenthses
on a method call is often used in Scala to draw attention to side effects.
We decided that using \code{()} in read barriers was warranted, however;
although read barriers don't perform any visible mutation, their access
to shared mutable state does require extra care.  The current CCSTM code
base uses \code{apply()} for concise transactional reads.

\end{packed_enum}

For fields that are almost always accessed inside an atomic block, we
sometimes found it convenient to create transactional accessor methods.
The full \type{Ref} is published via a longer name for non-transactional
or advance operations, while the basic property name is available within
a transaction using Scala's basic field syntax:
\lstset{numbers=none}
\lstset{xleftmargin=0.125in}
\begin{lstlisting}
class Node {
  val nextRef: Ref[Node] = ..
  def next(implicit txn: Txn): Node = nextRef()
  def next_=(v: Node)(implicit txn: Txn) {
    nextRef := v 
  }
}
\end{lstlisting}
\lstset{xleftmargin=0.25in}
\lstset{numbers=left}

\subsection{Non-transactional reads}

The bound view returned by \type{Ref}\code{.nonTxn} makes
non-transactional reads and writes explicit.  This makes those accesses
visible in the code, and allows the compiler to statically check that
the remaining transactional accesses only occur within the static scope
of a \type{Txn}.  This also allows the implementation of escape actions.
An expert user may use the \code{nonTxn} view inside a transaction to
perform reads and writes that bypass an active transaction context.
The verbosity of explicit calls to \code{nonTxn} makes non-transactional
accesses inconvenient, but this may actually be beneficial if it discourages
premature optimization using relaxed isolation.

The main disadvantage that we have observed is that code composability is
hindered by the escape actions semantics of \code{nonTxn}.  The advanced
\type{Ref.Bound} operations such as \code{transform} and \code{getAndSet}
(Section~\ref{sec:advanced}) allow some small transactions to be
rewritten as a single operation, but this changes the semantics if
there is an active transaction.  This is similar to the problem that
led us to use dynamic scoping for nesting (Section~\ref{sec:hybrid}),
but with less possibility to amortize the costs of the required
\type{ThreadLocal} lookup.  We may add a third binding mechanism that
requests a transactional binding (like \type{Ref}\code{.bind}) if a
dynamic lookup finds an active transaction or a non-transactional binding
(like \type{Ref}\code{.nonTxn}) if none is found.

\subsection{Partial rollback of nested transactions}

We plan to extend CCSTM's implementation to support partial rollback.
This is important to properly support the \keyword{orElse} operator, and
it is also required to provide failure atomicity (rollback without retry
after a user exception).  The only changes to the CCSTM API required
for partial rollback are for the life cycle callbacks, which must be
extended to allow notification of the commit or rollback of a nested
context prior to the completion of the top level transaction.

\subsection{Collection classes}


