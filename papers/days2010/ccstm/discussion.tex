\subsection{Nested transactions}

CCSTM currently does not support nested atomic blocks, an important
omission.  A bigger problem, though, is that the static scoping
of transactions would make composing such blocks difficult.  If a
method \code{m} needs a transaction internally, should it add an
\keyword{implicit} \type{Txn} parameter?  If it doesn't, then it
cannot be composed.  If it does, then the caller must always allocate
an atomic block.  The the programmer wishes to provide both a simple
and a composable version of the method then he or she must come up with
two names.

A partial solution is provided by the \type{Ref} $\leftrightarrow$
\type{Ref.Bound} correspondence.  Rather than coming up with two
method names, the same method name can be used in two classes.
\type{Ref}\code{.nonTxn} and \type{Ref.Bound}\code{.unbind} switch from
one type to the other.  While it may be tolerable to manage these parallel
classes in the library itself, it seems onerous to ask the programmer to
perform a similar task.

Another option is to provide dynamic scoping for the declaration of atomic
blocks, but static scoping for barriers.  Since barriers are likely to be much
more common than nested transactions, there is less performance motivation
for avoiding a thread-local lookup.  This seems like it might be the best
solution, although we are wary of mixing static and dynamic scoping.

