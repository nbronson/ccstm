
STM research is mature enough that the most difficult design decisions
for CCSTM were all found in the interface.

\subsection{Read barrier syntax}
\label{sec:syntax}

The most difficult syntactic choice was the method name for a
transactional read.  Four alternatives were considered:

\begin{packed_enum}

\item Using property syntax to emulate a \keyword{var }\code{ elem}
in the \type{Ref} class -- To read the transactional value held by a
reference \code{x} the caller would use \code{x.elem}, and to update it
they would write \code{x.elem = v}.  This approach is self-consistent,
but it is much too verbose.

\item An implicit conversion from \xtype{Ref}{A} to \typeparam{A} --
This is the most concise, but it interferes with further implicit
conversions, and with type inference for generic methods or data
structures.  If \code{x} is a \ytype{Ref}{String} holding \code{"foo"},
for example, \code{("foo" == x)} would return false.

\item \code{unary\_!} -- A unary operator is the most concise explicit
way of denoting a read, and prefix forms of these are the only ones
that don't trigger Scala's line merging heuristic.  Initially we
settled on a \code{!} prefix for reads.  This works well for arithmetic
expressions, but it can be confusing when used in a conditional test,
as in \code{(!x == "foo")}.  It also does not chain well, requiring
extra parentheses: \code{(!x).length}.  Because of these problems, we
found ourself often reverting to the more verbose forms \code{(x.get ==
"foo")} and \code{x.get.length}.

\item \code{apply()} -- This is the only operator-like method that can
safely occur at the end of the line, which allows it to be placed after
the expression that produces the \type{Ref} to read.  This means that
it chains properly in complex operations.  We initially avoided using
\code{apply()} for read barriers, because inclusion of optional parenthses
on a method call is often used in Scala to draw attention to side effects.
We decided that using \code{()} in read barriers was warranted, however;
although read barriers don't perform any visible mutation, their access
to shared mutable state does require extra care.  The current CCSTM code
base uses \code{apply()} for concise transactional reads.

\end{packed_enum}

For fields that are almost always accessed inside an atomic block, we
sometimes found it convenient to create transactional accessor methods.
The full \type{Ref} is published via a longer name for non-transactional
or advance operations, while the basic property name is available within
a transaction using Scala's basic field syntax:
\lstset{numbers=none}
\lstset{xleftmargin=0.125in}
\begin{lstlisting}
class Node {
  val nextRef: Ref[Node] = ..
  def next(implicit txn: Txn): Node = nextRef()
  def next_=(v: Node)(implicit txn: Txn) {
    nextRef := v 
  }
}
\end{lstlisting}
\lstset{xleftmargin=0.25in}
\lstset{numbers=left}

\subsection{Non-transactional reads}

The bound view returned by \type{Ref}\code{.nonTxn} makes
non-transactional reads and writes explicit.  This makes those accesses
visible in the code, and allows the compiler to statically check that
the remaining transactional accesses only occur within the static scope
of a \type{Txn}.  This also allows the implementation of escape actions.
An expert user may use the \code{nonTxn} view inside a transaction to
perform reads and writes that bypass an active transaction context.
The verbosity of explicit calls to \code{nonTxn} makes non-transactional
accesses inconvenient, but this may actually be beneficial if it discourages
premature optimization using relaxed isolation.

The main disadvantage that we have observed is that code composability is
hindered by the escape actions semantics of \code{nonTxn}.  The advanced
\type{Ref.Bound} operations such as \code{transform} and \code{getAndSet}
(Section~\ref{sec:advanced}) allow some small transactions to be rewritten
as a single operation, but this changes the semantics if there is an
active transaction.  This is similar to the problem that led us to use
dynamic scoping for nesting (Section~\ref{sec:hybrid}), but with less
possibility to amortize the costs of the required \type{ThreadLocal}
lookup.
We may add a third binding mechanism that requests a transactional
binding (like \type{Ref}\code{.bind}) if a dynamic lookup finds an active
transaction or a non-transactional binding (like \type{Ref}\code{.nonTxn})
if none is found.

\subsection{Partial rollback of nested transactions}

We plan to extend CCSTM's implementation to support partial rollback.
This is important to properly support the \keyword{orElse} operator, and
it is also required to provide failure atomicity (rollback without retry
after a user exception).  The only changes to the CCSTM API required
for partial rollback are for the life cycle callbacks, which must be
extended to allow notification of the commit or rollback of a nested
context prior to the completion of the top level transaction.

\color{green}
\subsection{Nested transactions}

CCSTM currently does not support nested atomic blocks, an important
omission.  A larger problem, though, is that the static scoping
of transactions would make composing such blocks difficult.  If a
method \code{m} needs a transaction internally, should it add an
\keyword{implicit} \type{Txn} parameter?  If it doesn't, then it
cannot be composed.  If it does, then the caller must always provide
an atomic block.  If the programmer wishes to provide both a simple
and a composable version of the method then he must come up with
two names.

The need for two versions of \code{m} parallels the transactional and
non-transactional access to a \type{Ref}, which was resolved there by the
\type{Ref} $\leftrightarrow$ \type{Ref.Bound} correspondence.  Rather than
coming up with two method names, the same method name can be used in
two classes.  \type{Ref}\code{.nonTxn} and \type{Ref.Bound}\code{.unbind}
convert from an instance suitable for one context to the other.  While it
may be tolerable to manage these parallel classes in the library itself,
it seems burdensome to ask the programmer to perform a similar task.

A possible solution is to provide dynamic scoping for the declaration
of atomic blocks, but static scoping for barriers.  Because nested
transactions are likely to be less common than barriers, there is less
performance motivation for avoiding the thread-local lookup.

It seems dangerous to mix static and dynamic scoping, but we notice that
for all but the most subtle uses, the static and dynamic scopes should be
identical.  This means that we can provide an execution mode that checks
the
static scopes against the dynamic ones, and triggers an exception 
if they don't match.  This checking mode would be slower on a per-barrier
basis, so like asserts it might be disabled during production use.

For applications that don't spend a large portion of their time in barriers, we
should also consider providing full dynamic scoping for transactions.
Interestingly, this could be enabled in a per-module fashion by providing an
implicit function that performs the required thread-local lookup.  The result
might look like:
\lstset{numbers=none}
\begin{lstlisting}
class Account ... {
  import STM.dynamic

  def deposit(amount: Money) {
    assert(amount >= 0)
    _balance := _balance() + amount
  }
}
\end{lstlisting}
\lstset{numbers=left}
If \code{deposit} were executed outside a transaction a runtime error would be
generated, rather than the compile-time error produced by the existing CCSTM.

Future: Partial rollback

Future: Collections

Future: Plugin

Future: @specialized

\color{black}
