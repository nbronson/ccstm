The proliferation of multi-core processors means that more programmers are
being thrust into the difficult world of shared memory multi-threading.
Software transactional memory (STM) provides a compelling alternative to
locks for managing access to shared mutable state; STM's declarative
atomic blocks are free from deadlock, are composable, and do not
require elaborate fine-grained decomposition to yield scalability.

%The benefits of memory transactions stem from an optimistic execution
%strategy that includes rollback and retry.  The ability to recover from
%error allows the runtime to
%attempt concurrent execution without a guarantee that it is possible.
%STMs bridge the gap between their simple programming model and their
%speculative execution by isolating uncommitted transactions from the
%rest of the system.  Most of the difficulty in integrating an STM into
%a language comes from tradeoffs between the overhead, fidelity, and
%complexity of this isolation.

In this paper we describe the design of CCSTM, a library-based STM
for Scala.  CCSTM deliberately sidesteps many of the 
semantic difficulties common in software implementations of transactional
memory, by limiting its focus: we view CCSTM as a domain-specific language
for use by parallel programmers that wish to build algorithms and data
structures using optimistic concurrency control.  CCSTM is not a drop-in replacement for
locks, an all-encompassing concurrent programming model, or a mechanism
for automatic parallelization of arbitrary code.

The most fundamental design choice for CCSTM was the decision to
implement it entirely as a Scala library.  Unlike STMs that transparently
instrument
all loads from and stores to shared mutable state, transactional accesses in CCSTM are explicit
method calls to a Scala \keyword{trait}\footnote{Custom accessor methods
may used to eliminate the syntactic overhead for some situations.}.
We refer to the resulting STM as `reference-based', because all memory
locations managed by the STM are boxed inside transactional references.
Both transactional and non-transactional access to the managed references
goes through methods implemented by instances of this \xtype{Ref}{A}.

While a reference-based STM imposes a syntactic burden for simple loads and
stores, it also provides advantages.  Encapsulating transactionally-managed
data eliminates the weak isolation issues that plague transparent STMs.
The \type{Ref} provides
a first-class object that names a memory location, which enables the
expression of higher-level constructs such as a simple but effective form of
semantic conflict detection.
The reference also provides a convenient
namespace for additional STM functionality.
%As a
%practical benefit, the extra level of indirection provided by \type{Ref}
%allows multiple implementations, allowing tradeoffs between the cost of
%validation and the likelihood of rollback.

CCSTM's second departure from the typical STM interface is that it binds the
transaction scope statically, rather than dynamically.  Transactional access
methods in \type{Ref} take an implicit parameter of type \type{Txn}, and
perform their accesses in the context of that transaction.
%This decision
%was made for pragmatic reasons, because performing a dynamically-scoped
%lookup on each transactional access would be prohibitively expensive.
A useful parallel can be made between Haskell's STM~\cite{harris05ctm} and CCSTM.
Haskell's \type{TVar} corresponds to instances of type \type{Ref}.
\type{Txn} is not a monad, but it proliferates through STM-enabled
methods in exactly the same way as the \type{STM} monad.

In this paper:
\begin{packed_enum}

\item We describe CCSTM, a reference-based STM for Scala.  CCSTM focuses on
helping parallel programmers build optimistically concurrent algorithms
and data structures, while restricting itself to implementation techniques
that do not interfere with components of the system that do not use it
(Section~\ref{sec:ref}).

\item We introduce \code{unrecordedRead}, a new STM primitive that relaxes
read atomicity while allowing manual validation, and \code{map}, a simple
and safe way of expressing semantic conflict detection.  A transaction
that reads a refrence \code{x} via \code{x.map(f)} does not need to roll
back if \code{x} is changed concurrently but \code{f(x.get)} remains
the same (Section~\ref{sec:unrecordedread}).

\item We summarize the discussions that led from the original design goal to
the current syntax.  We point out the parts that work well and the parts that
are burdensome, and hypothesize about ways to address the latter
(Section~\ref{sec:syntax}).

\item We compare the performance of CCSTM to DeuceSTM, an STM for
the JVM that use bytecode rewriting~\cite{deucestm}.
We find that CCSTM's implementation as an
unprivileged library does not impose a significant performance penalty
(Section~\ref{sec:perf}).

\end{packed_enum}

