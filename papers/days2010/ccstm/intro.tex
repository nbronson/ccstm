The proliferation of multi-core processors means that more programmers are
being thrust into the difficult world of shared memory multi-threading.
Software transactional memory (STM) provides a compelling alternative to
locks for managing access to shared mutable state; STM's declarative
atomic blocks are free from deadlock, are composable, and do not
require elaborate fine-grained decomposition to yield scalability.

%The benefits of memory transactions stem from an optimistic execution
%strategy that includes rollback and retry.  The ability to recover from
%error allows the runtime to
%attempt concurrent execution without a guarantee that it is possible.
%STMs bridge the gap between their simple programming model and their
%speculative execution by isolating uncommitted transactions from the
%rest of the system.  Most of the difficulty in integrating an STM into
%a language comes from tradeoffs between the overhead, fidelity, and
%complexity of this isolation.

In this paper we describe the design of CCSTM, a library-based STM
for Scala.  CCSTM deliberately sidesteps many of the 
semantic difficulties common in software implementations of transactional
memory, by limiting its focus.  We view CCSTM as a domain specific language
(DSL)
for use by parallel programmers that wish to build algorithms and data
structures using optimistic concurrency control.  CCSTM is not a drop-in replacement for
locks, an all-encompassing concurrent programming model, or a mechanism
for automatic parallelization of arbitrary code.

The most fundamental design choice for CCSTM was the decision to implement
it entirely as a Scala library.  Unlike STMs that transparently instrument
all loads and stores of shared mutable state, accesses in CCSTM are
explicit method calls on a Scala \keyword{trait} \type{Ref}.  We refer to
the resulting STM as `reference-based', because memory locations managed
by the STM are accessed only through an additional level of indirection.

While a reference-based STM adds one or two characters of program text
to basic loads and stores, it leads to a safer and more full-featured
interface.  The encapsulation of transactionally-managed data allows CCSTM
to provide strong atomicity and isolation with no performance impact on
code that doesn't use the STM.  In addition, \type{Ref} instances provide
a first-class entity that names a memory location, which enables CCSTM
to provide additional functionality to the user in a natural way.

%As a
%practical benefit, the extra level of indirection provided by \type{Ref}
%allows multiple implementations, allowing tradeoffs between the cost of
%validation and the likelihood of rollback.

CCSTM departs from the dynamic transaction scoping typical of STMs, using
a hybrid approach.  \type{Ref}'s methods locate the transaction via an
implicit parameter of type \type{Txn}, which must be part of the lexical
scope during compilation; this avoids the overhead of a dynamic lookup for
most calls to the STM.  Nesting of atomic regions, however, is resolved
dynamically using a \type{ThreadLocal}; this avoids the need to add an
implicit \type{Txn} parameter to every method called inside a transaction.

%This decision
%was made for pragmatic reasons, because performing a dynamically-scoped
%lookup on each transactional access would be prohibitively expensive.
%A useful parallel can be made between Haskell's STM~\cite{harris05composable} and CCSTM.
%Haskell's \type{TVar} corresponds to instances of type \type{Ref}.
%\type{Txn} is not a monad, but it proliferates through STM-enabled
%methods in exactly the same way as the \type{STM} monad.

In this paper:
\begin{packed_enum}
\setlength{\itemsep}{5pt}

\item We describe CCSTM, a reference-based STM for Scala.  CCSTM focuses
on helping parallel programmers build optimistically concurrent algorithms
and data structures, while restricting itself to implementation techniques
that do not interfere with components of the system that do not use it
(Section~\ref{sec:ref}).

\item We show how a hybrid of static and dynamic transaction scoping can
be used to reduce the performance penalty of a library-based STM while
retaining ease of use (Section~\ref{sec:hybrid}).

\item We introduce \code{unrecordedRead}, an STM primitive that relaxes
read atomicity while allowing manual validation
(Section~\ref{sec:unrecordedread}).

%.  To demonstrate its
%use, we implement \type{Ref}\code{.map}, a simple but powerful form of
%Abstract Nested Transaction~\cite{harris07abstract}
%(Sections~\ref{sec:unrecordedread}
%and~\ref{sec:map}).

\item We briefly present CCSTM's implementation, including a
novel optimization for isolation write barriers
(Section~\ref{sec:impl}).

\item We demonstrate that although CCSTM is an unprivileged library,
its performance is comparable to JVM STMs that use bytecode rewriting
(Section~\ref{sec:perf}).

\item We summarize some of the discussions that led from the original
design goal to the current syntax.  We point out the parts that work
well and the parts that are cumbersome, and hypothesize about ways to
address the latter (Section~\ref{sec:discussion}).

\end{packed_enum}

