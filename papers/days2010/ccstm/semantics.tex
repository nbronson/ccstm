
CCSTM provides strong semantic guarantees for the memory locations that it
manages, but does not attempt to hide the fact that transactions may be
executed more than once.
\todo{cursor}

\subsection{Strong isolation}

One of the benefits of the reference-based approach is that it avoids
isolation problems between transactional and non-transactional accesses to
the same memory location, without requiring any changes to the underlying
type system.

At its most basic, a software transactional memory is a way of isolating
a group of memory accesses and verifying that those accesses are
equivalent to some serial execution.  The STM manages reads and writes
by redirecting them to \textit{barriers}, code fragments that actually
implement the atomicity and isolation.  These properties can only be
guaranteed, however, if no non-transactional code bypasses the barriers
and accesses a memory location directly.

There are three potential responses to the weak isolation between direct memory
accesses and concurrent transactions:
\begin{packed_itemize}

\item The system can provide strong isolation and atomicity by redirecting
all memory accesses to barriers, even non-transactional accesses.
While there has been some research in using dynamic recompilation
to reduce the performance penalty of strong isolation, these require
either deep integration with the VM's JIT~\cite{schneider08dynamic}
or a substantial warmup period~\cite{bronson09dbo}.

\item The system can declare that a conflicting concurrent access
from both inside and outside a transaction is an error.  This doesn't
sound too onerous, but the optimistic nature of transactions means that
failed speculations must also be considered: inconsistent transactions
may execute conflicting accesses from an impossible branch, or they
may execute conflicting accesses after they have become doomed.
Restrictions on commit order can prevent some of the most surprising
behaviors~\cite{sgla08}, but the resulting systems still require
whole-program reasoning to guarantee correctness.  The privatization
problem and its dual, the publication problem, refer to isolation failure
for specific useful idioms.

\item The system can use types to disallow direct access to any memory
location that might be touched transactionally~\cite{moore08semantics}.
This can take the form of extending the types and access rules on normal
mutable memory locations, or of boxing all transactionally-managed
data inside some sort of cell, as in Haskell~\cite{harris05composable}
or Clojure~\cite{hickey08clojure}.  We refer to the latter approach as
a reference-based STM.

\end{packed_itemize}

Scala favors safety and compile-time checking of program correctness,
so the authors are of the opinion that it is only natural to employ types
to avoid the problems of weak isolation.  In the long term, an extension
to Scala's types seems possible, but in the short term a reference-based
approach seems the most practical.

\subsection{Opacity}

A subtle issue with STM is that, unless special care is taken, only
committed transactions are guaranteed to be consistent.  Speculative
transactions may observe an inconsistent state and only subsequently
detect that they should roll back.  These `zombies' can produce
surprising behavior by taking impossible branches or performing
transactional accesses to the wrong object.  This problem is greatly
magnified in a reference based STM, because the STM cannot provide a
sandbox that isolates all actions taken by the zombie.  The read of a
single impossible value may produce an infinite loop, so a transparent
STM must either prevent inconsistent reads or instrument back edges
to periodically revalidate the transaction.  Only the first option is
available to an STM implemented as a library.

The TL2~\cite{dice06tl2} and LSA~\cite{riegel06lsa} algorithms
demonstrated how to use a global time-stamp to efficiently validate
a transaction after each read, guaranteeing consistency for all
intermediate states.  This correctness property was later formalized
as \textit{opacity}~\cite{guerraoui08opacity}.  CCSTM is based on
SwissTM~\cite{dragojevic09swisstm}, which adds eager detection of
write-write conflicts to TL2's algorithm.

\subsection{Irrevocable actions and structural conflicts}

One of the side effects of CCSTM's alternate syntax for transactional barriers
is that it avoids creating the impression that the STM can magically
parallelize all existing sequential code, or that atomic blocks are
always a better replacement for locks.  There are both semantic and
practical reasons why this is not the case, even for implicit STMs.

The semantic problems come
from actions that the STM cannot isolate or undo, such as I/O or calls to
external libraries.  In the absence of any additional information about
potential conflicts, the only way to execute safely is to serialize.
CCSTM does not try to automatically handle irrevocable actions, but
it provides handlers that allow user code to implement a variety of
strategies.  Five types of callbacks may be registered with a transaction:
\begin{packed_itemize}

\item{\it before-completion} -- invoked before the transaction attempts to
commit, regardless of whether it is already doomed;

\item{\it read-resource} -- invoked each time the transaction's read
set is validated, if any (CCSTM's algorithm can avoid validation for
some read-only transactions);

\item{\it write-resource} -- participates in a two-phase commit, voting on the
outcome and then receiving the consensus decision;

\item{\it after-commit} -- invoked after the transaction has committed, but
before the application has been informed of the success; and

\item{\it after-rollback} -- invoked after the transaction has rolled back, but
before it is retried or failure is reported to the application.

\end{packed_itemize}

The practical problem with executing code that was not designed to
be executed inside an atomic block is that such code often contains
incidental shared accesses that the STM must treat as conflicts.
An example of this is the size field of a collection, which is often
accessed by every mutating operation.  Unless care is taken to distribute
the size over multiple memory locations, no concurrency will actually
be available.

CCSTM provides several mechanisms for reducing transaction conflicts with
semantic conflict detection.  A sophisticated user can combine CCSTM's
\code{unrecordedRead} primitive (Section~\ref{sec:unrecordedread}) with
lifecycle callbacks to manually implement their own conflict detection.
For simpler cases \type{Ref}\code{.map} (Section~\ref{sec:map})
makes it trivial to use Abstract Nested Transactions (ANTs) to avoid
rollback~\cite{harris07abstract}.  For the special case of contention
on integer values, CCSTM provides \type{LazyConflictIntRef}, which
uses an implicit ANT for inequalities, increment, and decrement; and
\type{StripedIntRef}, which is optimized for low-contention increment
and decrement with occasional reads.
