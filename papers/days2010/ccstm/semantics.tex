
CCSTM provides strong semantic guarantees for the memory locations that it
manages, but does not attempt to hide the fact that transactions may be
executed more than once.  All accesses to \type{Ref} instances are strongly
isolated and atomic, and transactions guarantee opacity.  CCSTM does not
handle or prevent irrevocable actions inside transactions.  Instead, it provides a
rich set of life cycle callbacks that allow a variety of strategies to be
implemented.

\subsection{Strong isolation}

One of the benefits of the reference-based approach is that it avoids
isolation problems between transactional and non-transactional accesses to
the same memory location, without requiring any changes to the underlying
type system.

At its most basic, a software transactional memory is a way of isolating a
group of memory accesses and verifying that those accesses are equivalent
to some serial execution.  The STM barriers that perform the transactional
reads and writes include code that blocks or rolls back any accesses that
violate atomicity or isolation.  If non-transactional code bypasses the
barriers and accesses an STM-managed memory location directly, however,
the barriers can no longer detect all violations.

There are three potential responses to the weak isolation between direct memory
accesses and concurrent transactions:
\begin{packed_itemize}

\item The runtime can provide strong isolation and atomicity by redirecting
all memory accesses to barriers, even non-transactional accesses.
While there has been some research in using dynamic recompilation
to reduce the performance penalty of strong isolation, these require
either deep integration with the VM's JIT~\cite{schneider08dynamic}
or a substantial warmup period~\cite{bronson09dbo}.

\item The language can declare that a conflicting concurrent access
from both inside and outside a transaction is an error.  This doesn't
sound too onerous, but the optimistic nature of transactions means that
failed speculations must also be considered: inconsistent transactions
may execute conflicting accesses from an impossible branch, or they
may execute conflicting accesses after they have become doomed.
Restrictions on commit order can prevent some of the most surprising
behaviors~\cite{sgla08}, but the resulting systems still require
whole-program reasoning to guarantee correctness.  The privatization
problem and its dual, the publication problem, refer to isolation failure
for specific useful idioms.

\item The type system can prevent direct access to any memory
location that might be touched transactionally~\cite{moore08semantics}.
This can take the form of extending the type and access rules on normal
mutable memory locations, or of encapsulating transactionally-managed
data as private variables of some sort of cell, as in Haskell~\cite{harris05composable}
and Clojure~\cite{hickey08clojure}.  We refer to the latter approach as
a reference-based STM.

\end{packed_itemize}

Scala favors safety and compile-time checking of program correctness,
so the authors are of the opinion that it is only natural to employ types
to avoid the problems of weak isolation.  In the long term, an extension
to Scala's types seems possible, but in the short term a reference-based
approach seems the most practical.  CCSTM provides strong isolation by
encapsulating all transactionally-managed memory locations inside 
references.

\subsection{Opacity}

A subtle issue with STM is that, unless special care is taken, only
committed transactions are guaranteed to be consistent.  Speculative
transactions may observe an inconsistent state and only subsequently
detect that they should roll back.  These `zombies' can produce
surprising behavior by taking impossible branches or performing
transactional accesses to the wrong object.  This problem is greatly
magnified in a reference based STM, because the STM cannot provide a
sandbox that isolates all actions taken by the zombie.  The read of a
single impossible value may produce an infinite loop, so a transparent
STM must either prevent inconsistent reads or instrument back edges
to periodically revalidate the transaction.  Only the first option is
available to an STM implemented as a library.

\todo{McRT?}
The TL2~\cite{dice06tl2} and LSA~\cite{riegel06lsa} algorithms
use a global time-stamp to efficiently validate
a transaction after each read, guaranteeing consistency for all
intermediate states.  This correctness property is formalized
as \textit{opacity}~\cite{guerraoui08opacity}.  CCSTM is based on
SwissTM~\cite{dragojevic09swisstm}, which adds eager detection of
write-write conflicts to TL2's validation algorithm.

\subsection{Irrevocable actions and structural conflicts}

One of the side effects of CCSTM's alternate syntax for transactional barriers
is that it avoids creating the impression that the STM can magically
parallelize all existing sequential code, or that atomic blocks are
always a better replacement for locks.  There are both semantic and
practical reasons why this is not the case, even for STMs with deep
integration into the VM.

The semantic problems with hiding rollback and retry come
from actions that the STM cannot isolate or undo, such as I/O or calls to
external libraries.
CCSTM does not try to automatically handle irrevocable actions.  Instead,
it provides handlers that allow user code to implement a variety of
strategies.  Five types of callbacks may be registered with a transaction:
\begin{packed_itemize}

\item{\it before-completion} -- invoked before the transaction attempts to
commit, regardless of whether it is already doomed;

\item{\it read-resource} -- invoked each time the transaction's read
set is validated (CCSTM can avoid validation for
most read-only transactions);

\item{\it write-resource} -- participates in a two-phase commit, voting on the
outcome and then receiving the consensus decision;

\item{\it after-commit} -- invoked after the transaction has committed, but
before the application has been informed of the success; and

\item{\it after-rollback} -- invoked after the transaction has rolled back, but
before it is retried or failure is reported to the application.

\end{packed_itemize}

The practical problem with executing code that was not designed to
be executed inside an atomic block is that such code often contains
incidental shared accesses that the STM must treat as conflicts.
An example of this is the size field of a collection, which is often
accessed by every mutating operation.  Unless care is taken to distribute
this variable over multiple memory locations, no concurrency will actually
be available.

CCSTM provides several mechanisms for reducing transaction conflicts with
semantic conflict detection.  A sophisticated user can combine the
\code{releasableRead} or \code{unrecordedRead} primitive (Section~\ref{sec:unrecordedread}) with
lifecycle callbacks to manually implement their own conflict detection.
For simple cases, \type{Ref}\code{.map} (Section~\ref{sec:map})
makes it trivial to use Abstract Nested Transactions (ANTs) to avoid
rollback~\cite{harris07abstract}.  For the special case of contention
on integer values, CCSTM includes \type{LazyConflictIntRef}, which
uses ANTs for all inequality comparisons, increments, and decrements, and
\type{StripedIntRef}, which is optimized for low-contention increment
and decrement with occasional reads.  Both of these classes implement
\ytype{Ref}{Int}.
