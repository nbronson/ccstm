%\documentclass{sigplanconf}
\documentclass[preprint,nocopyrightspace]{sigplanconf}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{textcomp}
\usepackage[usenames]{color}
\usepackage{graphicx}
\usepackage{url}
\usepackage{rotating}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{array}
\usepackage[T1]{fontenc}
\usepackage{luximono}

\newenvironment{packed_enum}{
\begin{enumerate}
  \setlength{\topsep}{0pt}
  \setlength{\itemsep}{5pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{enumerate}}

\newenvironment{packed_itemize}{
\begin{itemize}
  \setlength{\topsep}{0pt}
  \setlength{\itemsep}{5pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{itemize}}

\newcommand{\todo}[1]{{\color{red} \bf [TODO: #1 ]}}


\lstdefinelanguage{Scala}{
  morestring=[b]",
  morestring=[b]',
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morekeywords={var,val,def,private,class,object,trait,implicit,if,else,new,do,while,@volatile,try,catch,case,match,throw,return,extends,with,import}
}

\lstset{
  language=Scala,
%  basicstyle=\fontsize{7.5}{9}\selectfont\tt,
  basicstyle=\fontsize{7}{8}\selectfont\tt,
%  basicstyle=\selectfont\tt,
  keywordstyle=\bfseries,
  numbers=left,
  numberstyle=,
  commentstyle=\itshape,
  columns=fixed,
  xleftmargin=0.25in,
  firstnumber=auto,
  escapechar=\#,
  emph={A,B,C,K,V,U,Z}, emphstyle=\bfseries\itshape,
  emph={[2]Unit,Int,Set,Map,TSet,TMap,TVar,Option,Boolean,Txn,Money,Account,OverdraftException,Ref,Source,Sink,Bound,ReadResource}, emphstyle={[2]\itshape}
}

\newcommand{\code}[1]{{\fontsize{8}{9.5}\selectfont \tt #1}}
\newcommand{\codesec}[1]{{\fontsize{10}{12}\selectfont \tt \bfseries #1}}
\newcommand{\codeft}[1]{{\fontsize{6.5}{8}\selectfont \tt #1}}
\newcommand{\type}[1]{{\code{\itshape #1}}}
\newcommand{\typesec}[1]{{\codesec{\itshape #1}}}
\newcommand{\typeparam}[1]{{\code{\bfseries #1}}}
\newcommand{\typeparamsec}[1]{{\codesec{\bfseries #1}}}
\newcommand{\xtype}[2]{{\type{#1}\typeparam{[#2]}}}
\newcommand{\xtypesec}[2]{{\typesec{#1}\typeparamsec{[#2]}}}
\newcommand{\ytype}[2]{{\type{#1}\code{[}\type{#2}\code{]}}}
\newcommand{\xxtype}[3]{{\type{#1}\typeparam{[#2,#3]}}}
%\newcommand{\keyword}[1]{{\code{\bfseries #1}}}
\newcommand{\keyword}[1]{{\code{#1}}}

\hyphenation{CC-STM}
\hyphenation{Deuce-STM}
\hyphenation{Mul-ti-verse}

\begin{document}

\conferenceinfo{Scala Workshop,}{April 15, 2010, Lausanne, Switzerland.}
\CopyrightYear{2010}
\copyrightdata{}

\newcommand{\xtitle}[0]{CCSTM: A Library-Based STM for Scala}
\newcommand{\xterms}[0]{{Algorithms, Languages}}
\newcommand{\xkeywords}[0]{{Transactional memory, Scala}}
%\titlebanner{[WORK IN PROGRESS: Do Not Circulate!]}        % These are ignored unless
\preprintfooter{\xtitle}  % 'preprint' option specified.

\title{\xtitle}

\authorinfo{Nathan G. Bronson \and Hassan Chafi \and Kunle Olukotun}
           {Computer Systems Laboratory\\
            Stanford University}
           {\textit{\{nbronson, hchafi, kunle\}@stanford.edu}}

\pdfinfo{
  /Title    (\xtitle)
  /Author   (Nathan G. Bronson and Hassan Chafi and Kunle Olukotun)
  /Subject  (\xterms)
  /Keywords (\xkeywords)
}

\maketitle

\begin{abstract}

We introduce CCSTM, a library-based software transactional memory (STM)
for Scala, and give an overview of its design and implementation.
Our design philosophy is that CCSTM should be a useful tool for the
parallel programmer, rather than a parallelization mechanism for arbitrary
sequential code, or the sole synchronization primitive in a system.

%This frees us from the semantic tar pits that surround privatization,
%strong isolation, and irrevocable system calls.

CCSTM expresses transactional reads and writes as explicit method calls on
instances of a reference type.  Scala's flexible method names, implicit
parameters, and closures keep the syntax concise, and the reference
instances provide a natural way to express additional STM functionality.
We use a novel hybrid of static and dynamic transaction scoping to
retain composability while avoiding the barrier overheads that would
otherwise result from an implementation as an unprivileged library.
Experiments show that CCSTM's performance and scalability are
on par with bytecode rewriting STMs.


%Transactional accesses in CCSTM are performed via explicit method calls
%on instances that implement a trait \type{Ref}.  These transactional
%references may be long-lived, or may be transient accessors to bulk
%transactional data such as an array.  Scala's operator overloading keeps
%the syntactic overhead low for basic reads and writes.  The \type{Ref}
%trait serves as a first-class representation of a transactionally-managed
%memory location, providing a natural way to express additional STM
%functionality such as modular blocking, non-transactional compare-and-swap,
%manually-validated reads, and deferrable transformation using pure
%functions.
%
%In an additional departure from typical STM designs, CCSTM uses a
%hybrid of static and dynamic transaction scoping.  \type{Ref}'s methods
%are bound to current transaction via a \keyword{implicit} parameter.
%When an atomic block is entered, however, nesting is resolved dynamically.
%This hybrid approach avoids the overheads of a dynamic lookup for most
%STM operations without requiring the transaction to be statically threaded
%throughout the user's code.

\end{abstract}

\category{D.1.3}{Programming Techniques}{Concurrent Programming -- Parallel programming}
\category{D.4.1}{Operating Systems}{Process Management -- Concurrency; Synchronization; Threads}

\terms
\xterms

\keywords
\xkeywords

\section{Introduction}
\label{sec:intro}
\input{intro.tex}

\input{fig_example_nosync.tex}

\section{Motivation}
\label{sec:library}
\input{library.tex}

%\section{\xtypesec{Ref}{A} and \xtypesec{Ref.Bound}{A}}
\section{The Basic Interface}
\label{sec:ref}
\input{ref.tex}

\section{Advanced Functionality}
\label{sec:advanced}
\input{advanced.tex}

\section{Semantics}
\label{sec:semantics}
\input{semantics.tex}

\section{Implementation}
\label{sec:impl}
\input{impl.tex}

\section{Performance}
\label{sec:perf}
\input{perf.tex}

\section{Discussion and Future Work}
\label{sec:discussion}
\input{discussion.tex}

\section{Conclusion}
\label{sec:conclusion}
\input{conclusion.tex}

\appendix
\section{Code}

Source code for CCSTM is available under a BSD license from
\textsf{http://github.com/nbronson/ccstm} .

%%This is the text of the appendix, if you need one.

\acks

The authors would like to thank Daniel Spiewak and Peter
Veentjer for their helpful feedback during the design phase of CCSTM.

This work was supported by the Stanford Pervasive Parallelism Lab,
by Dept. of the Army, AHPCRC W911NF-07-2-0027-1, and by
the National Science Foundation under grant CNS--0720905.

{
%\small
\bibliographystyle{abbrv}
%\bibliographystyle{plainnat}
%\renewcommand{\bibfont}{\normalsize}
\bibliography{../../common/ppl}

%\begin{thebibliography}{10}
%\end{thebibliography}
}

\end{document}

