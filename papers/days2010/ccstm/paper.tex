%\documentclass{sigplanconf}
\documentclass[preprint]{sigplanconf}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{textcomp}
\usepackage[usenames]{color}
\usepackage{graphicx}
\usepackage{url}
\usepackage{rotating}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{array}
\usepackage[T1]{fontenc}
\usepackage{luximono}

\newenvironment{packed_enum}{
\begin{enumerate}
  \setlength{\topsep}{0pt}
  \setlength{\itemsep}{2pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{enumerate}}

\newenvironment{packed_itemize}{
\begin{itemize}
  \setlength{\topsep}{0pt}
  \setlength{\itemsep}{2pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{itemize}}

\newcommand{\todo}[1]{{\color{red} \bf [TODO: #1 ]}}


\lstdefinelanguage{Scala}{
  morestring=[b]",
  morestring=[b]',
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morekeywords={var,val,def,private,class,object,trait,implicit,if,else,new,do,while,@volatile,try,catch,case,match,throw,return,extends,with,import}
}

\lstset{
  language=Scala,
  basicstyle=\fontsize{7.5}{9}\selectfont\tt,
%  basicstyle=\fontsize{7}{8}\selectfont\tt,
%  basicstyle=\selectfont\tt,
  keywordstyle=\bfseries,
  numbers=left,
  numberstyle=,
  commentstyle=\itshape,
  columns=fixed,
  xleftmargin=0.25in,
  firstnumber=auto,
  escapechar=\#,
  emph={A,B,C,K,V,U,Z}, emphstyle=\bfseries\itshape,
  emph={[2]Unit,Int,Set,Map,TSet,TMap,TVar,Option,Boolean,Txn,Money,Account,OverdraftException,Ref,Source,Sink,Bound}, emphstyle={[2]\itshape}
}

\newcommand{\code}[1]{{\fontsize{8}{9.5}\selectfont \tt #1}}
\newcommand{\codesec}[1]{{\fontsize{10}{12}\selectfont \tt \bfseries #1}}
\newcommand{\codeft}[1]{{\fontsize{6.5}{8}\selectfont \tt #1}}
\newcommand{\type}[1]{{\code{\itshape #1}}}
\newcommand{\typesec}[1]{{\codesec{\itshape #1}}}
\newcommand{\typeparam}[1]{{\code{\bfseries #1}}}
\newcommand{\typeparamsec}[1]{{\codesec{\bfseries #1}}}
\newcommand{\xtype}[2]{{\type{#1}\typeparam{[#2]}}}
\newcommand{\xtypesec}[2]{{\typesec{#1}\typeparamsec{[#2]}}}
\newcommand{\ytype}[2]{{\type{#1}\code{[}\type{#2}\code{]}}}
\newcommand{\xxtype}[3]{{\type{#1}\typeparam{[#2,#3]}}}
%\newcommand{\keyword}[1]{{\code{\bfseries #1}}}
\newcommand{\keyword}[1]{{\code{#1}}}

\hyphenation{CC-STM}
\hyphenation{Deuce-STM}
\hyphenation{Mul-ti-verse}

\begin{document}

\conferenceinfo{Scala Workshop,}{April 15, 2010, Lausanne, Switzerland.}
\CopyrightYear{2010}
\copyrightdata{}

\newcommand{\xtitle}[0]{CCSTM: A Library-Based STM for Scala}
\newcommand{\xterms}[0]{{Algorithms, Performance}}
\newcommand{\xkeywords}[0]{{Optimistic Concurrency, Snapshot Isolation}}
%\titlebanner{[WORK IN PROGRESS: Do Not Circulate!]}        % These are ignored unless
\preprintfooter{\xtitle}  % 'preprint' option specified.

\title{\xtitle}

\authorinfo{Nathan G. Bronson \and Hassan Chafi \and Kunle Olukotun}
           {Computer Systems Laboratory\\
            Stanford University}
           {\textit{\{nbronson, hchafi, kunle\}@stanford.edu}}

\pdfinfo{
  /Title    (\xtitle)
  /Author   (Nathan G. Bronson and Hassan Chafi and Kunle Olukotun)
  /Subject  (\xterms)
  /Keywords (\xkeywords)
}

\maketitle

\begin{abstract}

We introduce CCSTM, a library-only
software transactional memory (STM) for Scala, and
give an overview of its design and implementation.
Our design philosophy is that CCSTM should be a useful tool for the
parallel programmer, rather than a parallelization mechanism for arbitrary
sequential code.  This frees us from the semantic tar pits that surround
privatization, strong isolation, and irrevocable system calls.
It also allows us to express the STM using Scala classes and methods, a design
choice that has far-reaching consequences.

Transactional accesses in CCSTM are performed through instances that
implement a trait \type{Ref}.  These transactional references may be
long-lived, or may be transient accessors to bulk transactional data such
as an array.  The syntax for dereferencing \type{Ref} instances is
a pain point for the library-based approach, but the reference-based
interface also provides benefits.  \type{Ref} serves as a first-class
representation of a transactionally-managed memory location, providing
a natural way to express additional STM features such as conditional
waiting, non-transactional compare-and-swap, manually-validated reads,
and deferrable transformation using pure functions.

In an additional departure from typical STM designs, CCSTM passes the
current transactional context through an implicit parameter, rather than
dynamically binding the transaction to the current thread.  This static
transaction scoping allows CCSTM to compete in performance with STMs that
perform bytecode rewriting, but it hinders composability.  We sketch
a potential solution to this problem that combines static scoping for
barriers and dynamic scoping for nested transactions.

\end{abstract}

\category{D.3.3}{Programming Languages}{Language Constructs and Features -- Concurrent programming structures}
\category{E.1}{Data Structures}{Trees}
\category{D.1.3}{Programming Techniques}{Concurrent Programming -- Parallel programming}

\terms
\xterms

\keywords
\xkeywords

\section{Introduction}
\label{sec:intro}
\input{intro.tex}

\section{Background}
\label{sec:library}
\input{library.tex}

%\section{\xtypesec{Ref}{A} and \xtypesec{Ref.Bound}{A}}
\section{CCSTM's interface}
\label{sec:ref}
\input{ref.tex}

\section{CCSTM's implementation}
\label{sec:impl}
\input{impl.tex}

\section{Discussion}
\label{sec:discussion}
\input{discussion.tex}
*Simple got more complicated
*Complicated got easier
*Implicit txn


Green Marker Notes:
~~~~~~~~~~~~~~~~~~~
txnal reference as a trait
    w/ multiple implementations
  - Clunky base syntax
  - Nice extended syntax
  - Optimized back ends (StripedIntRef, TIntRef,...)

Ref interface to collections
  - key is handle
  - TArray
  - THashMap

TxnFieldUpdater w/plugin

Syntax for atomic, orElse
  -tranformz
  -goal: good nonTxn support
        composition of ops on txn objects, 
        not actions in a transaction on all objects

%% \section{Performance}
%% \label{performance}
%% %\input{performance.tex}

%% \section{Conclusion}
%% \label{conclusion}
%% %\input{conclusion.tex}

\appendix
\section{Code}

Source code for CCSTM is available under a BSD license from
\textsf{http://github.com/nbronson/ccstm}.

%%This is the text of the appendix, if you need one.

\acks

The authors would like to specifically thank Daniel Spiewak and Peter
Veentjer for their helpful feedback during the design phase of CCSTM.

This work was supported by the Stanford Pervasive Parallelism Lab,
by Dept. of the Army, AHPCRC W911NF-07-2-0027-1, and by
the National Science Foundation under grant CNS--0720905.

{
%\small
\bibliographystyle{abbrv}
%\bibliographystyle{plainnat}
%\renewcommand{\bibfont}{\normalsize}
\bibliography{../../common/ppl}

%\begin{thebibliography}{10}
%\end{thebibliography}
}

\end{document}

