\begin{figure}
\begin{lstlisting}{name=Code}
class Ref[T] {
  def map[Z](f: T => Z)(implicit t: Txn): Z = {
    val u0 = unrecordedRead
    val result = f(u0.value)
    addReadResource(new Txn.ReadResource {
      var u = u0 // latest unrecorded read
  
      def valid(t: Txn) = {
        if (u.stillValid) {
          true
        } else {
          // reread and compare to original
          u = unrecordedRead
          (result == f(u.value))
        }
      }
    }, 0, false)
    result
  }
}
\end{lstlisting}

\caption{An implementation of \type{Ref}\code{.map} that combines the
\code{unrecordedRead} primitive with a read-resource life cycle callback.
Conflicting changes to the reference do not require the transaction to
be rolled back if \code{f(get)} does not change.}

\label{fig:map}
\end{figure}
