\begin{figure}
\begin{lstlisting}{name=Code}
class Ref[T] {
  ...
  def map[Z](f: T => Z)(implicit t: Txn): Z = {
    val u0 = unrecordedRead
    val result = f(u0.value)
    t.addReadResource(new Txn.ReadResource {
      var u = u0 // latest unrecorded read
  
      def valid(t2: Txn) = {
        if (u.stillValid) {
          true
        } else {
          // reread and compare to original
          u = unrecordedRead
          (result == f(u.value))
        }
      }
    }, 0, false)
    result
  }
}
\end{lstlisting}

\caption{\type{Ref}\code{.map} implemented by \code{unrecordedRead}
and a \type{ReadResource} callback.  The callback is invoked during read
set validation.  Conflicting changes to the reference do not require
the transaction to be rolled back if \code{f(get)} does not change.}

\label{fig:map}
\end{figure}
