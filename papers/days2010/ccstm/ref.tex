As a recurring example of the ways in which CCSTM allows optimistic concurrency
to be expressed, consider a class that encapsulates the balance of a
checking account\footnote{This example is from the bank benchmark included
in Deuce STM~\cite{deucestm}.}.  Absent any concurrency control, we might
write the code in Figure~\ref{fig:example:nosync}.  (Here \type{Money}
is an immutable numeric type suitable for representing quantities of
a currency.)  Adding pessimistic concurrency control to this code by
locking accesses to \type{Account} instances is not straightforward,
because both the source and destination account must be locked during
a \code{transfer}.  Unless a global lock order is followed this can
easily lead to deadlock.

\input{fig_example_nosync.tex}

CCSTM allows the atomic balance transfer to be expressed easily,
guaranteeing that both balance adjustments are performed atomically and
without deadlock.  Figure~\ref{fig:example:ccstm} shows one way to
express this using CCSTM.

\input{fig_example_ccstm.tex}

\input{fig_refclasses.tex}

\subsection{References -- \xtype{\bfseries Ref}{A} and \xtype{\bfseries Ref.Bound}{A}}

The most fundamental data type in CCSTM is \xtype{Ref}{A}, which mediates
access to an STM-managed mutable value.  Read-only methods are separated into a
covariant \type{Source} trait and write-only methods are separated into a
contravariant \type{Sink} trait.  The current transactional context is passed
during
each method call via an implicit parameter.  Reads and writes on a
reference may be performed with the \code{get} and \code{set} methods,
respectively, or with the more concise \code{apply()} and \code{:=}
operators.  Section~\ref{sec:syntax} discusses
the choice of method names in more detail.

Non-transactional access to the contents of a reference are provided by a view
returned by \code{nonTxn}.  This view implements methods that parallel those of
the reference, but that don't require a \type{Txn}.  We say that the view
is \textit{bound} to the non-transactional context, so the view trait is
named \type{Ref.Bound}.  Views may also be bound to a transactional context
via \type{Ref}\code{.bind}.  These bound references do not require a \type{Txn}
parameter, but may only be used until the end of the transaction.
Figure~\ref{fig:refclasses} shows the
\keyword{extends} relationship between the traits that implement unbound
and bound references, and some of their methods.  The separation between
\type{Ref}, \type{Source}, and \type{Sink}, and the operator syntax for
accesses are modeled after Spiewak's Scala STM~\cite{github:spiewak}.
The \type{Ref} $ \leftrightarrow $ \type{Ref.Bound} duality is unique
to CCSTM, as far as is known by the authors.

Bound views for non-transactional access create a syntactic difference
between transactional and non-transactional reads and writes.
This allows the expert programmer to selectively relax isolation by
performing a non-transactional access inside an atomic block, without
requiring an escape action.  The non-isolated access
is visually differentiated by including the token \code{nonTxn}.  In
Section~\ref{sec:unrecordedread} we will introduce \code{unrecordedRead},
a way of relaxing isolation for reads while retaining the ability to
manually validate it.

\subsection{Declaring and executing an atomic block}

Atomic execution is provided in CCSTM by the \code{atomic} method of
the \code{STM} object, which takes an argument with type
\type{Txn => }\typeparam{Z} and returns a value of type \typeparam{Z}.
We have found two idiomatic ways to bind the \type{Txn} to an implicit
value.

The most concise mechanism for expressing a short block of code is to use
Scala 2.8's support for the \keyword{implicit} modifier on parameters to
anonymous functions.  This form is shown in Figure~\ref{fig:example:ccstm}
on Lines~\ref{fig:example:ccstm:G} to~\ref{fig:example:ccstm:H}.

The most concise way to call a transactional method that declares an implicit
\type{Txn} parameter is to pass the partially applied method to
\code{STM.atomic}.  The \type{Account}\code{.transfer} method
might be decomposed into:
\lstset{numbers=none}
\begin{lstlisting}
def transfer(src: Account, dst: Account,
      amount: Money): Unit = {
  STM.atomic(transferInTxn(src, dst, amount)(_))
}
def transferInTxn(src: Account, dst: Account,
      amount: Money)(implicit txn: Txn): Unit = {
  src.withdraw(amount)
  dst.deposit(amount)
}
\end{lstlisting}
\lstset{numbers=left}

\todo{nesting}

The decision to statically scope CCSTM's transactions was made for
performance reasons.  To dynamically scope the transactions, the
current transaction must be identified by each read and write barrier.
This is an extremely frequent operation.  Bytecode rewriting STMs have
two options for efficiently performing this lookup: they can add a field
to the system-wide \type{Thread} class, or they can weave a \type{Txn}
parameter into the transactional version of every method.  A library-only
STM running on the JVM must restrict itself to \type{ThreadLocal},
which navigates from the \type{Thread} to a thread-local hash table,
and from there to the dynamically scoped value.

\subsection{Conditional retry}

CCSTM supports the \code{retry} and \code{orElse} primitives introduced by
Harris et al. in Haskell's STM~\cite{harris05ctm}, although the current
lack of partial rollback when nesting makes them less expressive than the original.
The \code{retry} primitive causes the surrounding transaction to be rolled
back, but retry is postponed until at least one of the values read by
the transaction has changed.  \code{orElse} combines two transactions,
attempting the second if the first calls \code{retry}, then blocking
both transactions if the second calls \code{retry}.  Intuitively, a call
to \code{retry} is a dead end; the STM will restart the transaction
only after it might take a different path.  Similarly, \code{orElse}
composes two alternatives that are each satisfactory, and requests that
whichever one can avoid the dead end should be executed.

Currently, CCSTM encodes \code{retry} as a method of the \code{STM} object, and 
combines composition and atomic execution of a sequence of atomic blocks into
\code{STM.atomicOrElse[}\typeparam{Z}\code{](blocks: (}\type{Txn}\code{ => }\typeparam{Z}\code{)*): }\typeparam{Z}.
While we have experimented with an implicit conversion from 
\type{Txn}\code{ => }\typeparam{Z} to an \type{AtomicBlock} that provides a
rich interface, we have not yet found a syntax that works well.  If
\code{retry} is used without \code{orElse}, then the normal \code{STM.atomic}
method may be used.

As a contrived example,
the bank could use modular blocking to withdraw money from exactly one of a number of
accounts, blocking until success:
\lstset{numbers=none}
\begin{lstlisting}
class Account {
  ...
  def withdrawOrRetry(m: Money
        )(implicit t: Txn) {
    if (_balance() < m) STM.retry
    _balance := _balance() - m
  }
}
object Account {
  def fromAny(m: Money, srcs: Account*) {
    val blocks = srcs map { s =>
        { (t: Txn) => s.withdrawOrRetry(m)(t) } }
    STM.atomicOrElse(blocks: _*)
  }
}
\end{lstlisting}
\lstset{numbers=left}

%Ref eq vs ==

\subsection{Relaxed isolation}
\label{sec:unrecordedread}

Some algorithms can benefit from transactional reads that are not atomic,
but that observe speculative stores made by the current transaction.
The inconsistent value may be used to make a heuristic decision, such as a
hash table resize, algorithm-specific knowledge may be used to guarantee
atomic behavior of the transaction despite a subsequent invalidation,
as in early release when searching a binary tree, or life cycle callbacks
may be used to provide customized validation.

Previous TM systems have provided several mechanisms for relaxing
atomicity and isolation.  Early release allows reads to be removed
from the read set prior to commit~\cite{HerlihyLMS03}.  Escape actions
suspend the current transaction temporarily~\cite{harris04exceptions}.
Open nested transactions allow the actions of a nested transaction
to be committed in a non-nested fashion.  CCSTM's static transaction
scoping makes escape actions trivial.  Accesses via \code{nonTxn}
are escaped when executed by the code that implements an atomic
block. CCSTM also provides principled support for early release,
via \type{Source.Bound.releasableRead}.  This method returns a
\type{ReleasableRead} instance that provides both the read value and
a method that removes the access from the transaction's read set.
This interface eliminates the danger that an algorithm will remove a
read that it did not perform, but it still requires careful reasoning
to provide correctness.  CCSTM does not support open nesting.

As an alternative to a releasable read, CCSTM provides a new
abstraction, \code{unrecordedRead}.  This method performs a
transactional read, but instead of adding an entry to the read set it
bundles the read's meta-data into an \type{UnrecordedRead} instance.
The caller may then use this instance to manually validate that the
returned value is still valid.

Like many STMs, CCSTM performs transactional reads by associating a
version number with each managed memory location, recording the version
prior to a transactional read, and checking during validation that the
version number remains unchanged.  An \type{UnrecordedRead} contains the
read value and the prior version, but rather than automatically validating
the read during commit, validation is exposed to the programmer via the
method \code{stillValid}.  An unrecorded read is considered to still be
valid if the only changes that have been made to the referenced memory
location were performed by the read's transaction.  This definition also
provides a meaning for unrecorded reads of the \code{nonTxn} bound view:
\code{stillValid} will return true only if no change has been made to the
managed value.  This leverages the STM's meta-data to solve
the ABA problem\footnote{The ABA problem is when an observer falsely
concludes that a value has not changed, because the watched value went
from A to B, then back to A.}.

\subsection{Semantic conflict detection for reads}
\label{sec:map}

Unrecorded reads can be paired with life cycle callbacks to implement
Abstract Nested Transactions~\ref{harris08abstract}.  For the simple case where
a single transactional read is modified by an idempotent function, we provide
\code{map[}\typeparam{Z}\code{](f: }\typeparam{T}\code{ => }\typeparam{Z}\code{): }\typeparam{Z}.

%\lstset{numbers=none}
%\begin{lstlisting}
%trait Source[+T] {
%  def map[Z](f: T => Z)(implicit txn: Txn): Z
%}
%\end{lstlisting}
%\lstset{numbers=left}
\code{x.map(f)} returns the same value as \code{f(x.get)}, but no rollback
is triggered by a conflicting write to \code{x} if the result of the mapping
does not change.  Without this
semantic conflict detection, the STM must initiate rollback any time \code{x}
is changed concurrently, even if that change is masked by the application of
\code{f}.

Consider a branch that should be taken only if the transactional value of
\code{x} is greater than 100, executed by a transaction $T$:
\lstset{numbers=none}
\begin{lstlisting}
  if (x() > 100) { ... }
\end{lstlisting}
\lstset{numbers=left}
If the observed value of \code{x} was 200 and a concurrent transaction $U$ commits
a change of \code{x} to 201, the STM must roll back $T$.  If the comparison is
moved inside \code{map}, however, no rollback is required:
\lstset{numbers=none}
\begin{lstlisting}
  if (x.map(_ > 100)) { ... }
\end{lstlisting}
\lstset{numbers=left}
By allowing the programmer to express more of his or her intention to CCSTM,
\code{map} reduces rollbacks and leads to better scalability.
Figure~\ref{fig:map} shows how \code{map} may be implemented using
\code{unrecordedRead} and a validation handler.

\input{fig_map.tex}

\subsection{All of the ways to read or write a CCSTM reference}

What follows is the complete listing of the access operations provided by
\type{Ref.Bound}.  Many of these methods have equivalents in \type{Ref}
that take an implicit \type{Txn}, although to reduce the API's surface
area not all are mirrored. \vspace{4pt}\\
\type{\bfseries Source.Bound}\textbf{ methods:}
\begin{packed_itemize}

\item \code{apply(): }\typeparam{T} -- Equivalent to \code{get}.

\item \code{get: }\typeparam{T} -- Reads the value managed by the
bound \type{Ref}.  If this view is bound to a non-transactional context,
the read will be strongly atomic and isolated with respect to all
transactions, and will linearize before returning.

\item \code{map[}\typeparam{Z}{](f: }\typeparam{T}{ => }\typeparam{Z}{): }\typeparam{Z}
-- Returns \code{f(get)}, possibly reevaluating \code{f}
to avoid rollbacks (\code{f} must be idempotent).

\item \code{await(p: }\typeparam{T}{ => }\type{Boolean}\code{)} -- Blocks
until \code{p(get)} is true.  Transactional contexts block by rolling
the transaction back using \code{retry}, the modular blocking primitive.
Non-transactional contexts just block.

\item \code{unrecordedRead: }\type{UnrecordedRead}\code{[}\typeparam{T}{]}
-- Returns an instance that wraps the value that would be returned by
\code{get}, but does not add anything to the transaction's read set
(if any).

\item \code{releasableRead: }\type{ReleasableRead}\code{[}\typeparam{T}{]}
-- Reads the value managed by the bound \type{Ref}, and returns that
value in an instance that allows the corresponding read set entry (if any)
to be removed.

\end{packed_itemize}
\type{\bfseries Sink.Bound}\textbf{ methods:}
\begin{packed_itemize}

\item \code{:=(v: }\typeparam{T}{)} -- Equivalent to \code{set(v)}.

\item \code{set(v: }\typeparam{T}{)} -- Updates the value managed by the
bound \type{Ref}.  If this view is bound to a non-transactional context,
this method will linearize the store before returning.

\item \code{tryWrite(v: }\typeparam{T}{): }\type{Boolean} -- Immediately
performs an update and returns true, or does nothing and returns false.

\end{packed_itemize}
\type{\bfseries Ref.Bound}\textbf{ methods:}
\begin{packed_itemize}

\item \code{readForWrite: }\typeparam{T} -- Returns the same value as
that returned by \code{get}, but adds the bound \type{Ref} to the write
set of the transaction context, if any.

\item \code{getAndSet(v: }\typeparam{T}{): }\typeparam{T} -- Atomically
invokes \code{set(v)} and returns the old value.  This is an atomic swap.

\item \code{compareAndSet(b: }\typeparam{T}{, v: }\typeparam{T}{): }\type{Boolean}
-- Equivalent to atomically executing:
\code{(b == get) \&\& \{ set(v); }\keyword{true}\code{ \}}

\item \code{compareAndSetIdentity(b: }\typeparam{T}{, v: }\typeparam{T}{): }\type{Boolean}
-- Equivalent to atomically:
\code{(b }\keyword{eq}\code{ get) \&\& \{ set(v); }\keyword{true}\code{ \}}

\item \code{weakCompareAndSet(b: }\typeparam{T}{, v: }\typeparam{T}{): }\type{Boolean}
-- Works like \code{compareAndSet(b, v)}, but allows spurious failures.

\item \code{weakCompareAndSetIdentity(b: }\typeparam{T}{, v: }\typeparam{T}{): }\type{Boolean}
-- Works like \code{compareAndSetIdentity(b, v)}, but allows spurious failures.

\item \code{transform(f: }\typeparam{T}{ => }\typeparam{T}{)} --
Atomically replaces the value \code{v} stored in the bound \type{Ref}
with \code{f(v)}.

\item \code{getAndTransform(f: }\typeparam{T}{ => }\typeparam{T}{): }\typeparam{T}
-- Atomically replaces the value \code{v} stored in the \type{Ref}
with \code{f(v)}, returning the old value.

\item \code{tryTransform(f: }\typeparam{T}{ => }\typeparam{T}{): }\type{Boolean} 
-- Immediately atomically transforms this reference and returns true,
or returns false.

\item \code{transformIfDefined(pf: PartialFunction[}\typeparam{T}{,}\typeparam{T}{]):} \\
\type{Boolean}
-- Atomically replaces the value \code{v} stored in the bound \type{Ref}
with \code{f(v)} if \code{pf.isDefinedAt(v)}, returning true, otherwise
leaves the value unchanged and returns false.

\end{packed_itemize}

