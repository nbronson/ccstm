
\input{fig_example_ccstm.tex}
\input{fig_refclasses.tex}

As a recurring example, consider a class that encapsulates the balance of
a checking account\footnote{This example is adapted from Deuce STM's bank
benchmark~\cite{deucestm}.}.  Absent any concurrency control, we might
write the code in Figure~\ref{fig:example:nosync}.  Adding pessimistic
concurrency control to this code by locking accesses to \type{Account}
instances is not straightforward, because both the source and destination
account must be locked during a \code{transfer}.  Unless a global lock
order is followed this can easily lead to deadlock.  CCSTM allows the
atomic balance transfer to be expressed easily, guaranteeing that both
balance adjustments are performed atomically and without deadlock.
Figure~\ref{fig:example:ccstm} shows one way to express this using CCSTM.


\subsection{References -- \xtype{\bfseries Ref}{A} and \xtype{\bfseries Ref.Bound}{A}}

The most fundamental data type in CCSTM is \xtype{Ref}{A}, which mediates
access to an STM-managed mutable value.  Read-only methods are separated into a
covariant \type{Source} trait and write-only methods are separated into a
contravariant \type{Sink} trait.  The current transactional context is passed
during
each method call via an implicit parameter.  Reads and writes on a
reference may be performed with the \code{get} and \code{set} methods,
respectively, or with the more concise \code{apply()} and \code{:=}
operators.  Section~\ref{sec:syntax} discusses
the choice of method names in more detail.

Non-transactional access to the contents of a reference are provided by a view
returned by \code{nonTxn}.  This view implements methods that parallel those of
the reference, but that don't require a \type{Txn}.  We say that the view
is \textit{bound} to the non-transactional context, so the view trait is
named \type{Ref.Bound}.  Views may also be bound to a transactional context
via \type{Ref}\code{.bind}.  These bound references do not require a \type{Txn}
parameter, but may only be used until the end of the transaction.
Figure~\ref{fig:refclasses} shows the
\keyword{extends} relationship between the traits that implement unbound
and bound references, and some of their methods.  The separation between
\type{Ref}, \type{Source}, and \type{Sink}, and the operator syntax for
accesses are modeled after Spiewak's Scala STM~\cite{github:spiewak}.
The \type{Ref} $ \leftrightarrow $ \type{Ref.Bound} duality is unique
to CCSTM, as far as is known by the authors.

Bound views for non-transactional access create a syntactic difference
between transactional and non-transactional reads and writes.
This allows the expert programmer to selectively relax isolation by
performing a non-transactional access inside an atomic block, without
requiring an escape action.  The non-isolated access
is visually differentiated by including the token \code{nonTxn}.  In
Section~\ref{sec:unrecordedread} we will introduce \code{unrecordedRead},
a way of relaxing isolation for reads while retaining the ability to
validate them.

\subsection{Declaring and executing an atomic block}

Atomic execution is provided in CCSTM by the \code{atomic} method of
the \code{STM} object, which takes an argument with type
\type{Txn => }\typeparam{Z} and returns a value of type \typeparam{Z}.
We have found two idiomatic ways to bind the \type{Txn} to an implicit
value.

\color{green}
The most concise mechanism for expressing a short block of code is to use
Scala 2.8's support for the \keyword{implicit} modifier on parameters to
anonymous functions.  This form is shown in Figure~\ref{fig:example:ccstm}
on Lines~\ref{fig:example:ccstm:G} to~\ref{fig:example:ccstm:H}.

The most concise way to call a transactional method that declares an implicit
\type{Txn} parameter is to pass the partially applied method to
\code{STM.atomic}.  The \type{Account}\code{.transfer} method
might be decomposed into:
\lstset{numbers=none}
\lstset{xleftmargin=0.125in}
\begin{lstlisting}
def transfer(src: Account, dst: Account,
      amount: Money): Unit = {
  STM.atomic(transferInTxn(src, dst, amount)(_))
}
def transferInTxn(src: Account, dst: Account,
      amount: Money)(implicit txn: Txn): Unit = {
  src.withdraw(amount)
  dst.deposit(amount)
}
\end{lstlisting}
\lstset{numbers=left}
\lstset{xleftmargin=0.25in}

\todo{nesting}

The decision to statically scope CCSTM's transactions was made for
performance reasons.  To dynamically scope the transactions, the
current transaction must be identified by each read and write barrier.
This is an extremely frequent operation.  Bytecode rewriting STMs have
two options for efficiently performing this lookup: they can add a field
to the system-wide \type{Thread} class, or they can weave a \type{Txn}
parameter into the transactional version of every method.  A library-only
STM running on the JVM must restrict itself to \type{ThreadLocal},
which navigates from the \type{Thread} to a thread-local hash table,
and from there to the dynamically scoped value.
\color{black}
