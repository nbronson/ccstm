
\input{fig_example_ccstm.tex}
\input{fig_refclasses.tex}

As a recurring example, consider a class that encapsulates the balance of
a checking account\footnote{This example is adapted from Deuce STM's bank
benchmark~\cite{deucestm}.}.  Absent any concurrency control, we might
write the code in Figure~\ref{fig:example:nosync}.  Adding pessimistic
concurrency control to this code by locking accesses to \type{Account}
instances is not straightforward, because both the source and destination
account must be locked during a \code{transfer}.  Unless a global lock
order is followed this can easily lead to deadlock.  CCSTM allows the
atomic balance transfer to be expressed easily, guaranteeing that both
balance adjustments are performed atomically and without deadlock.
Figure~\ref{fig:example:ccstm} shows one way to express this using CCSTM.


\subsection{References -- \xtype{\bfseries Ref}{A} and \xtype{\bfseries Ref.Bound}{A}}

The most fundamental data type in CCSTM is \xtype{Ref}{A}, which mediates
access to an STM-managed mutable value.  Read-only methods are separated into a
covariant \type{Source} trait and write-only methods are separated into a
contravariant \type{Sink} trait.  The current transactional context is passed
during
each method call via an implicit parameter.  Reads and writes on a
reference may be performed with the \code{get} and \code{set} methods,
respectively, or with the more concise \code{apply()} and \code{:=}
operators.  Section~\ref{sec:syntax} discusses
the choice of method names in more detail.

Non-transactional access to the contents of a reference are provided by a view
returned by \code{nonTxn}.  This view implements methods that parallel those of
the reference, but that don't require a \type{Txn}.  We say that the view
is \textit{bound} to the non-transactional context, so the view trait is
named \type{Ref.Bound}.  Views may also be bound to a transactional context
via \type{Ref}\code{.bind}.  These bound references do not require a \type{Txn}
parameter, but may only be used until the end of the transaction.
Figure~\ref{fig:refclasses} shows the
subclassing relationship between the traits that implement unbound
and bound references, and some of their methods.  The separation between
\type{Ref}, \type{Source}, and \type{Sink}, and the operator syntax for
accesses are modeled after Spiewak's Scala STM~\cite{github:spiewak}.
The \type{Ref} $ \leftrightarrow $ \type{Ref.Bound} duality is unique
to CCSTM, as far as is known by the authors.

Bound views for non-transactional access create a syntactic difference
between transactional and non-transactional reads and writes.
This allows the expert programmer to selectively relax isolation by
performing a non-transactional access inside an atomic block, without
requiring an escape action.  The non-isolated access
is visually differentiated by including the token \code{nonTxn}.  In
Section~\ref{sec:unrecordedread} we will introduce \code{unrecordedRead},
a way of relaxing isolation for reads while retaining the ability to
validate them.

\subsection{Declaring and executing an atomic block}

CCSTM's atomic blocks are functions with type
\code{(}\type{Txn}\code{ => }\typeparam{Z}\code{)}.
Transactional execution is provided by passing a block to the
\code{atomic} method of the \code{STM} object.  This method creates or
joins a transaction, passes the transaction context to the block, attempts
to commit the transaction, and retries the block if the transaction could not
be committed.

We have found two idiomatic ways to make the block's \type{Txn} argument available as
an implicit value.  For inline transactions, the most concise code adds the
\keyword{implicit} modifier to a closure's parameter\footnote{This syntax is new in
Scala 2.8.}, as shown in Figure~\ref{fig:example:ccstm}
on Lines~\ref{fig:example:ccstm:G} to~\ref{fig:example:ccstm:H}.  This syntax
can be shortened even further if \code{STM.atomic} is imported.
If the transaction's body consists only of a call to a method that threads the
implicit \type{Txn} parameter, the method can be passed to \code{STM.atomic} by
partially applying it.  In this style the \type{Account}\code{.tra\-ns\-fer} method
might be decomposed into:
\lstset{numbers=none}
\lstset{xleftmargin=0.125in}
\begin{lstlisting}
def transfer(src: Account, dst: Account, m: Money) {
  STM.atomic(transferInTxn(src, dst, m)(_))
}
def transferInTxn(src: Account, dst: Account,
      m: Money)(implicit txn: Txn) {
  src.withdraw(amount)
  dst.deposit(amount)
}
\end{lstlisting}
\lstset{numbers=left}
\lstset{xleftmargin=0.25in}

The decision to statically bind CCSTM's transactions to \type{Ref}
invocations was made for performance reasons.  To dynamically scope
the transactions, the current transaction must be identified by each
read and write barrier.  This is an extremely frequent operation.
Bytecode rewriting STMs have two options for efficiently performing this
lookup: they can add a field to the system-wide \type{Thread} class,
or they can weave a \type{Txn} parameter into the transactional version
of every method.  A library-based STM running on the JVM must restrict
itself to \type{ThreadLocal}, which navigates from the \type{Thread}
to a thread-local hash table, and from there to the dynamically scoped
value.  We do not include a detailed experimental comparison, but we
have observed that the cost of a single \type{ThreadLocal} lookup can
increase the per-read cost by up to 50\% over
performing statically-bound
reads in a large transaction.

\subsection{Dynamic scoping for nested transactions}
\label{sec:hybrid}

Statically scoped transactions using an implicit \type{Txn} are invisible
when making calls to \type{Ref}, but they add clutter when decomposing the
work of an atomic block into methods.  Each method that expects to be run
in a transaction must declare the implicit parameter.  This mechanism also
makes it difficult to make methods that can be called from both inside and
outside a transaction.  For example, the expected behavior for a call to
\code{deposit} from a non-transactional context is clear, but this won't
be allowed.  The worst pitfall of the purely-static approach comes if a
transaction is active but is not available in the lexical scope, leading
the user to create a new transaction that is not nested in the active one!

The solution is for \type{Ref}'s method to bind the \type{Txn} statically,
while \code{STM.atomic} searches the thread's dynamic scope for an active
\type{Txn}.  This means that a method that should be callable from either
context may omit the implicit \type{Txn} parameter and create a new atomic
block.  When called from a transactional context the new atomic block will
be nested or subsumed in the outer one.  With this strategy \code{deposit}
might be coded:

\lstset{numbers=none}
\lstset{xleftmargin=0.125in}
\begin{lstlisting}
def deposit(m: Money) {
  assert(m >= 0)
  STM.atomic { implicit t =>
    _balance := _balance() + m
  }
}
\end{lstlisting}
\lstset{numbers=left}
\lstset{xleftmargin=0.25in}

The current CCSTM implementation flattens nested transactions, so
when called from the atomic block in \code{transfer} this version of
\code{deposit} will perform its work in the outer context.  If called
when no transaction is active on the thread (regardless of the static
scope) it will create a new transaction.
