The proliferation of multi-core processors means that more programmers are
being thrust into the difficult world of shared memory multi-threading.
\todo{a couple sentences more of boilerplate motivation}

Software transactional memory (STM) provides a compelling alternative to
locks for managing access to shared mutable state.  STM's declarative
atomic blocks are free from deadlock, are composable, and do not
require elaborate fine-grained decomposition to yield scalability.
These benefits stem from an optimistic execution strategy that includes
rollback and retry, allowing the runtime to attempt concurrent execution
based only on a likelihood of success.  STMs bridge the gap between their
simple programming model and their speculative execution by isolating
uncommitted transactions from the rest of the system.

STMs often attempt to mimic the syntax used for lock-based critical
regions.  The beginning and end of the atomic block are declared, and all
code that is part of the dynamic scope of the atomic region is executed
transactionally.  This has the advantage that transactional accesses
inherit the programming language's syntax for reads and writes, which
is both concise and familiar.  This familiarity is both a blessing and
a curse, however.  It creates an expectation that the STM can safely
execute arbitrary existing sequential code, which creates both semantic
and performance challenges, and it makes it more difficult for the
programmer to convey semantic information to the STM, which reduces
opportunities for compile-time checking and run-time scalability and
performance improvements.

, since it creates an expectation that the STM can
safely execute all existing sequential code.

with scoping to
guarantee pairing, 

Introducing
an STM should provide the full benefits of transactional memory for
code that uses it, without imposing a burden on existing code or syntax.
The need to isolate code executed in a transaction from the rest of the system
makes such a ``pay as you go'' STM difficult:
\begin{packed_itemize}

\item \textbf{Strong isolation:}\footnote{Strong isolation is also 
referred to as strong atomicity.} Should non-transactional memory accesses be isolated from
acceses made inside a transaction?  If so, existing code will run slower, even
if it doesn't use transactions.  If not, programmers will be exposed to a
variety of semantic pitfalls.

\item \textbf{Instrumentation overhead:} STMs 

\item \textbf{Irrevocable actions:} What happens when a transaction performs
I/O, makes a native call, or does some other action that cannot be undone?
While better alternatives may be enumerated for specific cases, a
general-purpose STM 

\item 

\end{packed_itemize}

in the decision to add STM to an existing language.


To bridge the gap between the programming model and the execution
strategy, speculative 

provides the illusion of
atomicity and isolation, while allowing 


stem from an optimistic execution model that allows speculation, rollback,
and retry.  

The STM takes responsibility for ensuring that speculative
executions are isolated from actions taken by concurrent threads.

, while isolating incorrect speculations from concurrent threads.
Isolating 

Software transactions
solve the deadlock and composability problems inherent in pessimistic
locking, while at the same time presenting a simpler interface to the
programming.
