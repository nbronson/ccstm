\begin{figure}
\begin{lstlisting}{name=Code}
class Account(initialBalance: Money) {
  private val _balance = Ref(initialBalance)

  def balance: Source[Money] = _balance

  def deposit(m: Money)(implicit t: Txn) {
    assert(m >= 0)
    _balance := _balance() + m
  }

  def withdraw(m: Money)(implicit t: Txn) {
    assert(m >= 0)
    if (_balance() < m)
      throw new OverdraftException
    _balance := _balance() - m
  }
}

object Account {
  def transfer(src: Account, dst: Account,
               m: Money) {
    STM.atomic { implicit t => #\label{fig:example:ccstm:G}#
      src.withdraw(m)
      dst.deposit(m)
    } #\label{fig:example:ccstm:H}#
  }
}
\end{lstlisting}

\caption{One way to implement the atomic balance transfer function
using CCSTM.  This code uses \code{apply()} and \code{:=} operators
for performing transactional reads and writes, and expresses the atomic
block as an anonymous \type{Txn => Unit}.}

\label{fig:example:ccstm}
\end{figure}
