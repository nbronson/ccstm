
\subsection{Relaxed isolation}
\label{sec:unrecordedread}

Some algorithms can benefit from transactional reads that are not atomic,
but that observe speculative stores made by the current transaction.
The inconsistent value may be used to make a heuristic decision, such as a
hash table resize, algorithm-specific knowledge may be used to guarantee
atomic behavior of the transaction despite a subsequent invalidation,
as in early release when searching a binary tree, or life cycle callbacks
may be used to provide customized validation.

Previous TM systems have provided several mechanisms for relaxing
atomicity and isolation.  Early release allows reads to be removed
from the read set prior to commit~\cite{HerlihyLMS03}.  Escape actions
suspend the current transaction temporarily~\cite{harris04exceptions}.
Open nested transactions allow the actions of a nested transaction
to be committed in a non-nested fashion.  CCSTM's static transaction
scoping makes escape actions trivial.  Accesses via \code{nonTxn}
are escaped when executed by the code that implements an atomic
block. CCSTM also provides principled support for early release,
via \type{Source.Bound.releasableRead}.  This method returns a
\type{ReleasableRead} instance that provides both the read value and
a method that removes the access from the transaction's read set.
This interface eliminates the danger that an algorithm will remove a
read that it did not perform, but it still requires careful reasoning
to provide correctness.  CCSTM does not support open nesting.

As an alternative to a releasable read, CCSTM provides a new
abstraction, \code{unrecordedRead}.  This method performs a
transactional read, but instead of adding an entry to the read set it
bundles the read's meta-data into an \type{UnrecordedRead} instance.
The caller may then use this instance to manually validate that the
returned value is still valid.

Like many STMs, CCSTM performs transactional reads by associating a
version number with each managed memory location, recording the version
prior to a transactional read, and checking during validation that the
version number remains unchanged.  An \type{UnrecordedRead} contains the
read value and the prior version, but rather than automatically validating
the read during commit, validation is exposed to the programmer via the
method \code{stillValid}.  An unrecorded read is considered to still be
valid if the only changes that have been made to the referenced memory
location were performed by the read's transaction.  This definition also
provides a meaning for unrecorded reads of the \code{nonTxn} bound view:
\code{stillValid} will return true only if no change has been made to the
managed value.  This leverages the STM's meta-data to solve
the ABA problem\footnote{The ABA problem is when an observer falsely
concludes that a value has not changed, because the watched value went
from A to B, then back to A.}.

\subsection{Semantic conflict detection for reads}
\label{sec:map}

Unrecorded reads can be paired with life cycle callbacks to implement
Abstract Nested Transactions~\cite{harris07abstract}.  For the simple case where
a single transactional read is modified by an idempotent function, we provide
\code{map[}\typeparam{Z}\code{](f: }\typeparam{T}\code{ => }\typeparam{Z}\code{): }\typeparam{Z}.

%\lstset{numbers=none}
%\begin{lstlisting}
%trait Source[+T] {
%  def map[Z](f: T => Z)(implicit txn: Txn): Z
%}
%\end{lstlisting}
%\lstset{numbers=left}
\code{x.map(f)} returns the same value as \code{f(x.get)}, but no rollback
is triggered by a conflicting write to \code{x} if the result of the mapping
does not change.  Without this
semantic conflict detection, the STM must initiate rollback any time \code{x}
is changed concurrently, even if that change is masked by the application of
\code{f}.

Consider a branch that should be taken only if the transactional value of
\code{x} is greater than 100, executed by a transaction $T$:
\lstset{numbers=none}
\begin{lstlisting}
if (x() > 100) { ... }
\end{lstlisting}
\lstset{numbers=left}
If the observed value of \code{x} was 200 and a concurrent transaction $U$ commits
a change of \code{x} to 201, the STM must roll back $T$.  If the comparison is
moved inside \code{map}, however, no rollback would be required.  This would be
written:
\lstset{numbers=none}
\begin{lstlisting}
if (x.map(_ > 100)) { ... }
\end{lstlisting}
\lstset{numbers=left}
By allowing the programmer to express more of her intention to CCSTM,
\code{map} reduces rollbacks and leads to better scalability.
Figure~\ref{fig:map} shows how \code{map} may be implemented using
\code{unrecordedRead} and a validation handler.

\input{fig_map.tex}

\subsection{All of the ways to read or write a CCSTM reference}

\todo{formatting}

What follows is the complete list of the access operations provided by
\type{Ref.Bound}.  Many of these methods have equivalents in \type{Ref}
that take an implicit \type{Txn}, although to reduce the API's surface
area some methods are not mirrored.

{
\setlength{\leftskip}{12pt}
\setlength{\parindent}{-12pt}
\setlength{\parskip}{3pt}

\vspace{2pt}
\type{\bfseries Source.Bound:}

\code{apply(): }\typeparam{T }\\ Equivalent to \code{get}.

\code{get: }\typeparam{T }\\ Reads the value managed by the
bound \type{Ref}.  If this view is bound to a non-transactional context,
the read will be strongly atomic and isolated with respect to all
transactions, and will linearize before returning.

\code{map[}\typeparam{Z}\code{](f: }\typeparam{T}\code{ => }\typeparam{Z}\code{): }\typeparam{Z }\\
Returns \code{f(get)}, possibly reevaluating \code{f}
to avoid rollbacks (\code{f} must be idempotent).

\code{await(p: }\typeparam{T}\code{ => }\type{Boolean}\code{) }\\ Blocks
until \code{p(get)} is true.  Transactional contexts block by rolling
the transaction back using \code{retry}, the modular blocking primitive.
Non-transactional contexts just block.

\code{unrecordedRead: }\type{UnrecordedRead}\code{[}\typeparam{T}\code{] }\\
Returns an instance that wraps the value that would be returned by
\code{get}, but does not add anything to the transaction's read set
(if any).

\code{releasableRead: }\type{ReleasableRead}\code{[}\typeparam{T}\code{] }\\
Reads the value managed by the bound \type{Ref}, and returns that
value in an instance that allows the corresponding read set entry (if any)
to be removed.

\vspace{3pt}
\type{\bfseries Sink.Bound:}

\code{:=(v: }\typeparam{T}\code{) }\\ Equivalent to \code{set(v)}.

\code{set(v: }\typeparam{T}\code{) }\\ Updates the value managed by the
bound \type{Ref}.  If this view is bound to a non-transactional context,
this method will linearize the store before returning.

\code{tryWrite(v: }\typeparam{T}\code{): }\type{Boolean }\\ Immediately
performs an update and returns true, or does nothing and returns false.

\vspace{3pt}
\type{\bfseries Ref.Bound extends Source.Bound with Sink.Bound:}

\code{readForWrite: }\typeparam{T }\\ Returns the same value as
that returned by \code{get}, but adds the bound \type{Ref} to the write
set of the transaction context, if any.

\code{getAndSet(v: }\typeparam{T}\code{): }\typeparam{T }\\ Atomically
invokes \code{set(v)} and returns the old value.

\code{compareAndSet(b: }\typeparam{T}\code{, v: }\typeparam{T}\code{): }\type{Boolean }\\
Atomically performs
\code{(b == get) \&\& \{ set(v); }\keyword{true}\code{ \}}

\code{compareAndSetIdentity(b: }\typeparam{T}\code{, v: }\typeparam{T}\code{): }\type{Boolean }\\
Atomically performs
\code{(b }\keyword{eq}\code{ get) \&\& \{ set(v); }\keyword{true}\code{ \}}

\code{weakCompareAndSet(b: }\typeparam{T}\code{, v: }\typeparam{T}\code{): }\type{Boolean }\\
Either performs \code{compareAndSet} or returns false.

\code{weakCompareAndSetIdentity(b: }\typeparam{T}\code{, v: }\typeparam{T}\code{): }\type{Boolean }\\
Either performs \code{compareAndSetIdentity} or returns false.

\code{transform(f: }\typeparam{T}\code{ => }\typeparam{T}\code{) }\\
Atomically replaces the stored value \code{v} with \code{f(v)}.

\code{getAndTransform(f: }\typeparam{T}\code{ => }\typeparam{T}\code{): }\typeparam{T }\\
Atomically replaces the value \code{v} stored in the \type{Ref}
with \code{f(v)}, returning the old value.

\code{tryTransform(f: }\typeparam{T}\code{ => }\typeparam{T}\code{): }\type{Boolean } \\
Immediately atomically transforms this reference and returns true,
or returns false.

\code{transformIfDefined(pf: }\type{PartialFunction}\code{[}\typeparam{T}\code{,}\typeparam{T}\code{]):}
\type{Boolean }\\
Atomically replaces the value \code{v} stored in the bound \type{Ref}
with \code{f(v)} if \code{pf.isDefinedAt(v)}, returning true, otherwise
leaves the value unchanged and returns false.

}

\subsection{Removing storage indirection in user classes}

\todo{TxnFieldUpdater}

\subsection{Conditional retry}

CCSTM supports the \code{retry} and \code{orElse} primitives introduced by
Harris et al. in Haskell's STM~\cite{harris05ctm}, although the current
lack of partial rollback when nesting makes them less expressive than the original.
The \code{retry} primitive causes the surrounding transaction to be rolled
back, but retry is postponed until at least one of the values read by
the transaction has changed.  \code{orElse} combines two transactions,
attempting the second if the first calls \code{retry}, then blocking
both transactions if the second calls \code{retry}.  Intuitively, a call
to \code{retry} is a dead end; the STM will restart the transaction
only after it might take a different path.  Similarly, \code{orElse}
composes two alternatives that are each satisfactory, and requests that
whichever one can avoid the dead end should be executed.

Currently, CCSTM encodes \code{retry} as a method of the \code{STM} object, and 
combines composition and atomic execution of a sequence of atomic blocks into
\code{STM.atomicOrElse[}\typeparam{Z}\code{](blocks: (}\type{Txn}\code{ => }\typeparam{Z}\code{)*): }\typeparam{Z}.
While we have experimented with an implicit conversion from 
\type{Txn}\code{ => }\typeparam{Z} to an \type{AtomicBlock} that provides a
rich interface, we have not yet found a syntax that works well.  If
\code{retry} is used without \code{orElse}, then the normal \code{STM.atomic}
method may be used.

As a (hopefully) contrived example,
the bank could use modular blocking to withdraw money from exactly one of a number of
accounts, blocking until success:
\lstset{numbers=none}
\lstset{xleftmargin=0.125in}
\begin{lstlisting}
class Account {
  ...
  def withdrawOrRetry(m: Money
        )(implicit t: Txn) {
    if (_balance() < m) STM.retry
    _balance := _balance() - m
  }
}
object Account {
  def fromAny(m: Money, srcs: Account*) {
    val blocks = srcs map { s =>
        { (t: Txn) => s.withdrawOrRetry(m)(t) } }
    STM.atomicOrElse(blocks: _*)
  }
}
\end{lstlisting}
\lstset{numbers=left}
\lstset{xleftmargin=0.25in}

%Ref eq vs ==

